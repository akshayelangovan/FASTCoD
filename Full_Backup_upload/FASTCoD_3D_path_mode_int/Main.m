% Copyright 2021-2023, University of Cincinnati
% All rights reserved. See LICENSE file at:
% https://github.com/akshayelangovan/FASTCoD
% Additional copyright may be held by others, as reflected in the commit history.

% Author : Akshay Elangovan

clc
close all
clear

%% Defining system specifications
S.M = 2; % Mass of quadrotor
S.m = 1; % Mass of payload
S.l = 1; % Length of rigid cable
S.J = 0.17; % Moment of inertia of quadrotor
% S.M = 1; % Mass of quadrotor
% S.m = 0.5; % Mass of payload
% S.l = 1; % Length of rigid cable
% S.J = 38.6*4.4*10^(-3); % Moment of inertia of quadrotor

S.g = 9.81; % acceleration due to gravity

S.hover_F = (S.M+S.m)*S.g; % Maximum thrust generated by quadrotor
% S.max_tau = 0.5; % Maximum torque by quadrotor
S.max_tau = 10; % Maximum torque by quadrotor

S.max_pos_error = 3; % Max position error that is expected
S.max_vel_error = 3; % Max velocity error that is expected
% S.max_vel_roll = 1; % Max roll velocity (angular) that is permitted
S.max_vel_roll = 3; % Max roll velocity (angular) that is permitted

S.safe_distance = 2;

[Y,Z] = meshgrid(-3:1:3);
points = [Y(:),Z(:)];
X = ones(size(points,1),1)*3;

S.goal = [...
    -1 0 0;
    -4 0 0;
    -7 0 0];
S.waypoint_index = 1;
S.count = 0;

S.world = [X, points(:,1), points(:,2);
    points(:,1), points(:,2), -X;
    %-X, points(:,1), points(:,2);
    points(:,1), points(:,2), X;
    points(:,1), -X, points(:,2)
    points(:,1), X, points(:,2)];
    

i3 = 2/sqrt(3);
P.initstate = [...
    -1 0 0 -pi/4 0 0 0 0 0 0 0 0 0 0 0 0;
    2 0 0 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    2 0 0 pi/4 0 0 0 0 0 0 0 0 0 0 0 0;
    2 0 0 -pi/4 0 0 0 0 0 0 0 0 0 0 0 0;
    0 2 0 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    0 -2 0 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    0 0 2 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    0 0 -2 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    i3 i3 i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    i3 i3 -i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    i3 -i3 i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    i3 -i3 -i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    -i3 i3 i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    -i3 i3 -i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    -i3 -i3 i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    -i3 -i3 -i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0];
    
P.costfuncname = @FitFun_2;

P.ode = @myodefun; % function containing system equations for odesolver
P.fis1 = readfis('fisx_7x5'); % FIS files being tuned
P.fis2 = readfis('fisroll_7x5');
P.fis3 = readfis('fisz_noninverted_7x5');
P.fis4 = readfis('fisx_7x5'); % FIS files being tuned
P.fis5 = readfis('fisroll_7x5');
P.fis6 = readfis('fisyaw_7x5');
P.fis7 = readfis('OAFIS5');

P.fis8 = readfis('fisx_7x5'); % FIS files being tuned
P.fis9 = readfis('fisroll_7x5');
P.fis10 = readfis('fisz_noninverted_7x5');
P.fis11 = readfis('fisx_7x5'); % FIS files being tuned
P.fis12 = readfis('fisroll_7x5');

P.framespersec = 50;
P.T = 6; % duration of animation  in seconds
P.tspan=linspace(0,P.T,P.T*P.framespersec); % Generating time span

tic

load('M9aa.mat');
R0 = BestChrom.Gene;
load('M9ii.mat') 
R1 = BestChrom.Gene;
load('Y1.mat');% Trained controller chromosome + fitness || Y1 - yaw control in XY
R2 = BestChrom.Gene;

load('C3.mat') 
R3 = BestChrom.Gene;
load('C4i.mat') 
R4 = BestChrom.Gene;


for i = 1 : 35
    P.fis1.rule(i).consequent = R0(i);
    P.fis2.rule(i).consequent = R0(i + (35));
    P.fis3.rule(i).consequent = R0(i + 2*(35));
    P.fis4.rule(i).consequent = R1(i); % Assigning rules
    P.fis5.rule(i).consequent = R1(i + (35));
    P.fis6.rule(i).consequent = R2(i);
    
    P.fis8.rule(i).consequent = R3(i);
    P.fis9.rule(i).consequent = R3(i + (35));
    P.fis10.rule(i).consequent = R3(i + 2*(35));
    P.fis11.rule(i).consequent = R4(i); % Assigning rules
    P.fis12.rule(i).consequent = R4(i + (35));
end

toc

%% User interface
        disp('Running final_check.m for testing')
        disp('Check if all read files are correct')
        final_check;
 %% End       