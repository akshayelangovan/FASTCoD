%% Code for modularized training
% Author : Akshay Elangovan

clc
close all
clear

%% Defining system specifications
S.M = 2; % Mass of quadrotor
S.m = 2; % Mass of payload
S.l = 1.5; % Length of rigid cable
S.J = 0.17; % Moment of inertia of quadrotor
% S.M = 1; % Mass of quadrotor
% S.m = 0.5; % Mass of payload
% S.l = 1; % Length of rigid cable
% S.J = 38.6*4.4*10^(-3); % Moment of inertia of quadrotor

S.g = 9.81; % acceleration due to gravity

S.hover_F = (S.M+S.m)*S.g; % Maximum thrust generated by quadrotor
% S.max_tau = 0.5; % Maximum torque by quadrotor
S.max_tau = 10; % Maximum torque by quadrotor

S.max_pos_error = 3; % Max position error that is expected
S.max_vel_error = 3; % Max velocity error that is expected
% S.max_vel_roll = 1; % Max roll velocity (angular) that is permitted
S.max_vel_roll = 3; % Max roll velocity (angular) that is permitted

S.safe_distance = 2;

[Y,Z] = meshgrid(-3:1:3);
points = [Y(:),Z(:)];
X = ones(size(points,1),1)*3;



S.world = [X, points(:,1), points(:,2);
    points(:,1), points(:,2), -X;
    -X, points(:,1), points(:,2);
    points(:,1), points(:,2), X;
    points(:,1), -X, points(:,2)
    points(:,1), X, points(:,2)];
    

%% Defining training specifications
% Fitness function parameters
P.n_controllers = 3; % no. of controllers being trained
P.nrules = 24*3;
P.nvar = P.nrules * P.n_controllers; % nvar is no.of variables
% 49 is the number of rules to be tuned per controller
P.trainingcase = 'o'; % could also be z when n_controllers is 2

i3 = 2/sqrt(3);
P.initstate = [...
    0 0 0 -pi/4 pi/2 0 0 0 0 0 0 0 0 0 0 0;
    2 0 0 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    2 0 0 pi/4 0 0 0 0 0 0 0 0 0 0 0 0;
    2.3 0 0 -pi/4 0 0 0 0 0 0 0 0 0 0 0 0;
    0 2 0 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    0 -2 0 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    0 0 2 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    0 0 -2 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    i3 i3 i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    i3 i3 -i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    i3 -i3 i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    i3 -i3 -i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    -i3 i3 i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    -i3 i3 -i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    -i3 -i3 i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    -i3 -i3 -i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0];
    
P.costfuncname = @FitFun_2; % contains just the cost function equation (angular stabilization)
% fuzzy editing and ode solving is hardcoded as FitFun.m
% Note to self: Dont edit FitFun_1, instead create new function FitFun_2...
% Fuzzy parameters
P.lb = 1*ones(1,P.nvar); % lower bound of rules
P.ub = 3*ones(1,P.nvar); % upper bound of rules

P.ode = @myodefun; % function containing system equations for odesolver
% P.obj = @FitFun; % function containing cost/fitness equations
% P.obj is hardcoded into GeneticAlgorithm.m to prevent unnecessary
% communication overhead
P.fis1 = readfis('fisx_7x5'); % FIS files being tuned
P.fis2 = readfis('fisroll_7x5');
P.fis3 = readfis('fisz_noninverted_7x5');
P.fis4 = readfis('fisx_7x5'); % FIS files being tuned
P.fis5 = readfis('fisroll_7x5');
P.fis6 = readfis('fisyaw_7x5');
P.fis7 = readfis('OAFIS5');

P.fis8 = readfis('fisx_7x5'); % FIS files being tuned
P.fis9 = readfis('fisroll_7x5');
P.fis10 = readfis('fisz_noninverted_7x5');
P.fis11 = readfis('fisx_7x5'); % FIS files being tuned
P.fis12 = readfis('fisroll_7x5');

P.framespersec = 50;
P.T = 6; % duration of animation  in seconds
P.tspan=linspace(0,P.T,P.T*P.framespersec); % Generating time span

tic

load('M9aa.mat');
R0 = BestChrom.Gene;
load('M9ii.mat') 
R1 = BestChrom.Gene;
load('Y1.mat');% Trained controller chromosome + fitness || Y1 - yaw control in XY
R2 = BestChrom.Gene;

load('C3.mat') 
R3 = BestChrom.Gene;
load('C4i.mat') 
R4 = BestChrom.Gene;


for i = 1 : 35
    P.fis1.rule(i).consequent = R0(i);
    P.fis2.rule(i).consequent = R0(i + (35));
    P.fis3.rule(i).consequent = R0(i + 2*(35));
    P.fis4.rule(i).consequent = R1(i); % Assigning rules
    P.fis5.rule(i).consequent = R1(i + (35));
    P.fis6.rule(i).consequent = R2(i);
    
    P.fis8.rule(i).consequent = R3(i);
    P.fis9.rule(i).consequent = R3(i + (35));
    P.fis10.rule(i).consequent = R3(i + 2*(35));
    P.fis11.rule(i).consequent = R4(i); % Assigning rules
    P.fis12.rule(i).consequent = R4(i + (35));
end

toc

%% User interface
        disp('Running final_check.m for testing')
        disp('Check if all read files are correct')
        final_check;
 %% End       