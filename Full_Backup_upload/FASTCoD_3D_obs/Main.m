% Copyright 2021-2023, University of Cincinnati
% All rights reserved. See LICENSE file at:
% https://github.com/akshayelangovan/FASTCoD
% Additional copyright may be held by others, as reflected in the commit history.
%% Code for modularized training
% Author : Akshay Elangovan

clc
close all
clear

%% Defining system specifications
S.M = 2; % Mass of quadrotor
S.m = 1; % Mass of payload
S.l = 1; % Length of rigid cable
S.J = 0.17; % Moment of inertia of quadrotor
% S.M = 1; % Mass of quadrotor
% S.m = 0.5; % Mass of payload
% S.l = 1; % Length of rigid cable
% S.J = 38.6*4.4*10^(-3); % Moment of inertia of quadrotor

S.g = 9.81; % acceleration due to gravity

S.hover_F = (S.M+S.m)*S.g; % Maximum thrust generated by quadrotor
% S.max_tau = 0.5; % Maximum torque by quadrotor
S.max_tau = 10; % Maximum torque by quadrotor

S.max_pos_error = 3; % Max position error that is expected
S.max_vel_error = 3; % Max velocity error that is expected
% S.max_vel_roll = 1; % Max roll velocity (angular) that is permitted
S.max_vel_roll = 3; % Max roll velocity (angular) that is permitted
% S.x_goal = 0;
% S.y_goal = 0;
% S.z_goal = 0;
% S.yaw_goal = 0;
S.safe_distance = 2;

o3 = sqrt(3);
S.world = [...
    3,0,0;
    -3,0,0;
    0,3,0;
    0,-3,0;
    0,0,3;
    0,0,-3;
    o3,o3,o3;
    o3,o3,-o3;
    o3,-o3,o3;
    o3,-o3,-o3;
    -o3,o3,o3;
    -o3,o3,-o3;
    -o3,-o3,o3;
    -o3,-o3,-o3];

%% Defining training specifications
% Fitness function parameters
P.n_controllers = 3; % no. of controllers being trained
P.nrules = 24*3;
P.nvar = P.nrules * P.n_controllers; % nvar is no.of variables
% 49 is the number of rules to be tuned per controller
P.trainingcase = 'o'; % could also be z when n_controllers is 2
% P.initstate = [...
%     0 -1 0 0 0 0 0 0;
%     0 1 0 0 0 0 0 0] * 2.5;
% P.initstate = [...
%     0 0 0 0.001 0 0 0 0 0 0 0 0 0 0 0 0; % hover at origin - call 1
%     0 0 0 pi/4 0 0 0 0 0 0 0 0 0 0 0 0; % payload cable at pi/4 - call 2
%     0 0 0 -pi/4 0 0 0 0 0 0 0 0 0 0 0 0; % payload cable at -pi/4 - call 3
%     -3 0 0 0.001 0 0 0 0 0 0 0 0 0 0 0 0; % UAV at x = -3 - call 4
%     3 0 0 0.001 0 0 0 0 0 0 0 0 0 0 0 0; % UAV at x = 3 - call 5
%     0 0 -3 0.001 0 0 0 0 0 0 0 0 0 0 0 0; % UAV at z = -3 - call 6
%     0 0 3 0.001 0 0 0 0 0 0 0 0 0 0 0 0; % UAV at z = 3 - call 7
%     0 -3 0 0.001 0 0 0 0 0 0 0 0 0 0 0 0 % UAV at y = -3 - call 8
%     0 3 0 0.001 0 0 0 0 0 0 0 0 0 0 0 0; % UAV at y = 3 - call 9
%     3 -3 0 0.001 0 0 0 0 0 0 0 0 0 0 0 0 % UAV at x = 3 & y = -3 - call 10
%     -3 3 0 0.001 0 0 0 0 0 0 0 0 0 0 0 0; % UAV at x = -3 & y = 3 - call 11
%     0 0 0 0.001 0 0 0 pi/2 0 0 0 0 0 0 0 0;
%     0 0 0 0.001 0 0 0 -pi/2 0 0 0 0 0 0 0 0; 
%     0 0 0 0.001 0 0 0 pi/4 0 0 0 0 0 0 0 0;
%     0 0 0 0.001 0 0 0 -pi/4 0 0 0 0 0 0 0 0;
%     0 0 0 pi/4 pi/2 0 0 0 0 0 0 0 0 0 0 0; % payload cable at pi/4 in yz - call 16
%     0 0 0 -pi/4 pi/2 0 0 0 0 0 0 0 0 0 0 0]; % payload cable at -pi/4 in yz - call 17

i3 = 2/sqrt(3);
P.initstate = [...
    2 0 0 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    -2 0 0 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    0 2 0 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    0 -2 0 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    0 0 2 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    0 0 -2 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    i3 i3 i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    i3 i3 -i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    i3 -i3 i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    i3 -i3 -i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    -i3 i3 i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    -i3 i3 -i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    -i3 -i3 i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0;
    -i3 -i3 -i3 0.0001 0 0 0 0 0 0 0 0 0 0 0 0];
    
P.costfuncname = @FitFun_2; % contains just the cost function equation (angular stabilization)
% fuzzy editing and ode solving is hardcoded as FitFun.m
% Note to self: Dont edit FitFun_1, instead create new function FitFun_2...
% Fuzzy parameters
P.lb = 1*ones(1,P.nvar); % lower bound of rules
P.ub = 3*ones(1,P.nvar); % upper bound of rules

P.ode = @myodefun; % function containing system equations for odesolver
% P.obj = @FitFun; % function containing cost/fitness equations
% P.obj is hardcoded into GeneticAlgorithm.m to prevent unnecessary
% communication overhead
P.fis1 = readfis('fisx_7x5'); % FIS files being tuned
P.fis2 = readfis('fisroll_7x5');
P.fis3 = readfis('fisz_noninverted_7x5');
P.fis4 = readfis('fisx_7x5'); % FIS files being tuned
P.fis5 = readfis('fisroll_7x5');
P.fis6 = readfis('fisyaw_7x5');
P.fis7 = readfis('OAFIS4');

P.framespersec = 50;
P.T = 6; % duration of animation  in seconds
P.tspan=linspace(0,P.T,P.T*P.framespersec); % Generating time span

load('M9aa.mat');
R0 = BestChrom.Gene;

for i = 1 : 35
    P.fis1.rule(i).consequent = R0(i);
    P.fis2.rule(i).consequent = R0(i + (35));
    P.fis3.rule(i).consequent = R0(i + 2*(35));
end


load('M9ii.mat') 
R1 = BestChrom.Gene;

for i = 1:35
    fis4.rule(i).consequent = R1(i); % Assigning rules
    fis5.rule(i).consequent = R1(i + (35));
end

load('Y1.mat');% Trained controller chromosome + fitness || Y1 - yaw control in XY
R2 = BestChrom.Gene;

for i = 1 : 35
    fis6.rule(i).consequent = R2(i);
end

%% Defining genetic algorithm specifications

P.M = 360;%750; % Population size / No.of candidate solutions per generation
P.MaxGen = 2; % maximum number of generations / terminating condition

P.seed_status = 'random'; % type of initialization
% seed status can be 'random' which is basically random initialisation
% seed status can also be 'seeded' which initialises a random population
% with a part of it equal to a given seed

% check if length of seed is in accordance with training case
P.Pc = 0.95; % Probability of crossover
P.crossovername = 'double'; % type of crossover | can also be 'single'
P.Pm = 0.001; % Probability of mutation
P.Er = 0.2; % Elitism ratio
P.Pi = 0.001; % Probability of inversion

%% User interface
instruction = input('Do you want to "train" or "test"?  ','s');
switch instruction
    case 'train'
        tic
        disp("Commencing Training!")
        [cgcurve,avgcurve,BestPop] = GeneticAlgorithm(P,S);
        figure
        plot(1:P.MaxGen,-cgcurve)
        title('Best fitness value over generations')
        figure
        plot(1:P.MaxGen,-avgcurve,'.')
        title('Average fitness value over generations')
        BestChrom = BestPop(1);
        save('O1.mat','BestChrom')
        save('OPop1.mat','BestPop')
        histcurve.cgcurve = cgcurve;
        histcurve.avgcurve = avgcurve;
        save('O1_histdata.mat','histcurve')
        disp('Training complete!!!')
        disp('Training time:')
        toc
        poolobj = gcp('nocreate');
        delete(poolobj)
    case 'test'
        disp('Running final_check.m for testing')
        disp('Check if all read files are correct')
        final_check;
    otherwise
        disp('Invalid input | Please type train or test | Stopping program')
end
 %% End       